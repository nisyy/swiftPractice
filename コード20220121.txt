//ジェネリクス
//型を抽象化し、どのような型でも動作するように柔軟で再利用可能なコードを書くことができる。
struct Data<DataType> {
  var prop: DataType
}
// インスタンス化させるタイミングで型引数を指定する。型引数の型とイニシャライザの引数は同じ型にする必要がある。型推論も可
let data1 = Data<String>(prop: "data")
let data2 = Data(prop: 100)
print(data1.prop)
print(data2.prop)

//型の制約 スーパークラスやプロトコルを指定
protocol ItemProtocol {
  var item: String { get }
}
// 型引数を ItemProtocol に準拠させる
struct Data2<DataType: ItemProtocol> {
  var prop: DataType
}
struct Item: ItemProtocol {
  var item: String
}
// ItemProtocol に準拠した値を渡す
let data3 = Data2(prop: Item(item: "book"))
print(data3.prop.item)


//エクステンション
struct Data4<DataType> {
  var props: [DataType]
}
// whereを使って、制約をかける。
// DataTypeがString型のみエクステンションを有効にする
extension Data4 where DataType == String {
  func first() -> DataType? {
    props.first
  }
}
// String型の配列を渡す
let data4 = Data4(props: ["a", "b", "c"])
print(data4.first()!)


//ジェネリック関数
func tuple<T>(_ x: T, _ y: T) -> (T, T) {
  return (x, y)
}

// <型> で型引数を指定する
let tutple1 = tuple(1,2)
print(tutple1)


//型の制約 スーパークラスやプロトコルを指定
protocol ItemProtocol2 {
  var quantity: Int { get }
}

// ItemProtocolに準拠させる
func doubleQuantity<Item2: ItemProtocol2>(_ item: Item2) -> Int {
  return item.quantity * 2
}

struct Item2: ItemProtocol2 {
  var quantity: Int
}

// ItemProtocol に準拠した　Item2を渡す
let qty = doubleQuantity(Item2(quantity: 2))
print(qty)